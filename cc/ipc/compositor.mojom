// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

module cc.mojom;

import "cc/ipc/begin_frame_args.mojom";
import "cc/ipc/content_frame.mojom";
import "cc/ipc/layer_tree_settings.mojom";
import "cc/ipc/renderer_capabilities.mojom";
import "cc/ipc/surface_id.mojom";
import "cc/ipc/image_decode.mojom";
import "gpu/ipc/common/surface_handle.mojom";
import "ui/gfx/geometry/mojo/geometry.mojom";

// This is the main interface that the DisplayCompositor host uses
// to connect to the Display Compositor service.
interface DisplayCompositorFactory {
  CreateDisplayCompositor(DisplayCompositor& display_compositor,
                          DisplayCompositorClient display_compositor_client);
};

// GPU to browser/window server ("display compositor host").
interface DisplayCompositorClient {
  OnContentFrameSinkClientConnectionLost(
    CompositorFrameSinkId compositor_frame_sink_id);
  OnSurfaceCreated(gfx.mojom.Size frame_size, cc.mojom.SurfaceId surface_id);
};

// Browser or Window Server ("display compositor host") to GPU
interface DisplayCompositor {
  // A ContentFrameSink (and, similarly, this would apply for
  // CompositorFrameSink) is uniquely identified by two 32-bit quantities:
  // |client_id| and |sink_id|. |client_id| is a display compositor host
  // allocated ID that uniquely identifies a DisplayCompositorHost connection.
  // In Chrome, this is the RenderProcessHost ID. |sink_id| is a
  // client-allocated ID that uniquely identifies a sink for a given
  // DisplayCompositorHost connection. In Chrome, this is the routing ID.
  // TODO(fsamuel): We may wish to create more than one sink per view, and so
  // it might be useful to make the sink_id a 64-bit quantity.
  CreateContentFrameSink(uint32 client_id,
                         int32 sink_id,
                         gpu.mojom.SurfaceHandle widget,
                         cc.mojom.LayerTreeSettings settings,
                         ContentFrameSink& content_frame_sink,
                         ContentFrameSinkPrivate& content_frame_sink_private,
                         ContentFrameSinkClient content_frame_sink_client);
};

// Unprivileged DisplayCompositor API for clients implemented by the browser (on
// the IO thread) or window server.
interface DisplayCompositorHost {
  // There is a fixed client_id for a DisplayCompositorHost connection and thus
  // clients of this connection cannot allocate a new client_id.
  CreateContentFrameSink(int32 sink_id,
                         cc.mojom.LayerTreeSettings settings,
                         ContentFrameSink& content_frame_sink,
                         ContentFrameSinkClient content_frame_sink_client);
};

// This is a privileged API is used by the browser ONLY to allow creating
// onscreen ContentFrameSinks, and to add / convert refs on surface IDs. These
// private APIs ought not be necessary for Chrome in Mus+Ash. In Mus+Ash, Chrome
// delegates window creation to the Mus window server which has access to the
// privileged display compositor API.
interface DisplayCompositorHostPrivate {
  CreateContentFrameSinkWithHandle(
      int32 sink_id,
      gpu.mojom.SurfaceHandle widget,
      cc.mojom.LayerTreeSettings settings,
      ContentFrameSink& content_frame_sink,
      ContentFrameSinkClient content_frame_sink_client);

  RegisterContentFrameSinkObserver(
    CompositorFrameSinkId compositor_frame_sink_id,
    ContentFrameSinkPrivate& content_frame_sink_private,
    ContentFrameSinkObserver content_frame_sink_observer);
};

// ContentFrameSinkPrivate is used by the display compositor host to set up
// BeginFrameSource hierarchies. This API lives in SurfaceManager but is called
// from here in order to ensure that hierarchy registration does not race with
// ContentFrameSink creation.
interface ContentFrameSinkPrivate {
  // Adds a ref to this surface ID scoped by the lifetime of this
  // ContentFrameSink. That is, if the ContentFrameSink associated with this
  // interface goes away then so does the reference.
  AddRefOnSurfaceId(cc.mojom.SurfaceId id);

  // Transfers ownership of display compositor host's ref on to this client.
  TransferRef(cc.mojom.SurfaceId id);

  RegisterChildSink(CompositorFrameSinkId child_client_id);

  UnregisterChildSink(CompositorFrameSinkId child_client_id);
};

interface ContentFrameSinkObserver {
  OnClientConnectionLost();
  OnSurfaceCreated(gfx.mojom.Size frame_size, cc.mojom.SurfaceId surface_id);
};

// A ContentFrameSink corresponds to a LTH=>LTHI interface.
interface ContentFrameSink {
  SetNeedsBeginMainFrame();
  SetNeedsRedraw(gfx.mojom.Rect damage_rect);
  SetVisible(bool visible);
  BeginMainFrameAborted(cc.mojom.CommitEarlyOutReason reason);
  PrepareCommit(SurfaceId surface_id,
                bool will_wait_for_cativation,
                ContentFrame frame);
  [Sync] WaitForActivation() => ();
  DeleteBackings(array<uint32> backings);
  [Sync] Destroy() => ();
};

// A ContentFrameSinkClient corresponds to a LTHI=>LTH interface.
interface ContentFrameSinkClient {
  OnCompositorCreated(CompositorFrameSinkId compositor_frame_sink_id);
  OnBackingsReturned(array<uint32> backings);
  OnBeginMainFrame(uint32 begin_frame_id, BeginFrameArgs args);
  OnBeginMainFrameNotExpectedSoon();
  OnDidCompletePageScaleAnimation();
  OnDidCommitAndDrawFrame();
  OnDidCompleteSwapBuffers(SurfaceId surface_id);
  OnRendererCapabilities(RendererCapabilities capabilities);
  OnImageDecodeProxyCreated(ImageDecode& decode);
};
