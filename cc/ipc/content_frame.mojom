module cc.mojom;

import "cc/ipc/layer.mojom";
import "cc/ipc/ui_resource.mojom";
import "cc/ipc/surface_id.mojom";
import "ui/gfx/geometry/mojo/geometry.mojom";
import "ui/gfx/mojo/transform.mojom";

struct TransformCachedNodeData {
  gfx.mojom.Transform from_target;
  gfx.mojom.Transform to_target;
  gfx.mojom.Transform from_screen;
  gfx.mojom.Transform to_screen;
  int32 target_id;
  int32 content_target_id;
};

struct TransformTree {
  array<int8> nodes;
  bool source_to_parent_updates_allowed;
  float page_scale_factor;
  float device_scale_factor;
  float device_transform_scale_factor;
  array<int32> nodes_affected_by_inner_viewport_bounds_delta;
  array<int32> nodes_affected_by_outer_viewport_bounds_delta;
  array<TransformCachedNodeData> cached_data;
};

struct EffectTree {
  array<int8> nodes;
  array<int32> mask_replica_layer_ids;
};

struct ClipTree {
  array<int8> nodes;
};

struct SyncedScrollOffset {
  gfx.mojom.ScrollOffset pending_base;
  gfx.mojom.ScrollOffset active_base;
  gfx.mojom.ScrollOffset active_delta;
  gfx.mojom.ScrollOffset reflected_delta_in_main_tree;
  gfx.mojom.ScrollOffset reflected_delta_in_pending_tree;
  bool clobber_active_value;
};

struct ScrollTree {
  array<int8> nodes;
  int32 currently_scrolling_node_id;
  map<int32, SyncedScrollOffset> layer_id_to_scroll_offset_map;
};

struct PropertyTrees {
  TransformTree transform_tree;
  EffectTree effect_tree;
  ClipTree clip_tree;
  ScrollTree scroll_tree;
  bool non_root_surfaces_enabled;
  bool changed;
  bool full_tree_damaged;
  int32 sequence_number;
  bool verify_transform_tree_calculations;
};

enum LayerTreeOp {
  CHILD_LAYER,
  MOVE_TO_PARENT,
};

enum LayerType {
  BASE,
  PICTURE,
  // TODO(hackathon): PICTURE_IMAGE,
  SOLID_COLOR,
  // TODO(hackathon): SOLID_COLOR_SCROLLBAR
  PAINTED_SCROLLBAR,
  // TODO(hackathon): NINE_PATCH,
  SURFACE,
  // TODO(hackathon): TEXTURE,
  // TODO(hackathon): UI_RESOURCE,
  // TODO(hackathon): VIDEO
};

struct LayerStructure {
  LayerType layer_type;
  int32 layer_id;
  bool is_mask;  // Only for PictureLayer
  bool scrollbar_orientation_is_horizontal;  // Only for ScrollbarLayer
};

struct LayerTree {
  array<cc.mojom.LayerStructure> layers;
};

struct UIResourceRequestQueue {
  array<cc.mojom.UIResourceRequestProperties> ui_resource_requests;
};

struct ContentFrame {
  uint32 source_frame;
  bool next_commit_forces_redraw;
  bool needs_full_tree_sync;
  bool has_transparent_background;
  bool have_scroll_event_handlers;
  uint32 background_color;  // SkColor
  int32 overscroll_elasticity_layer;
  int32 page_scale_layer;
  int32 inner_viewport_scroll_layer;
  int32 outer_viewport_scroll_layer;
  float page_scale_factor;
  float min_page_scale_factor;
  float max_page_scale_factor;
  gfx.mojom.Vector2dF elastic_overscroll;
  bool has_gpu_rasterization_trigger;
  bool content_is_suitable_for_gpu_rasterization;
  gfx.mojom.Size device_viewport_size;
  float device_scale_factor;
  float painted_device_scale_factor;

  PropertyTrees property_trees;
  // This exists iff needs_full_tree_sync is true.
  LayerTree? layer_tree;
  array<cc.mojom.LayerProperties> layer_properties;
  array<cc.mojom.SurfaceId> released_surfaces;

  UIResourceRequestQueue? ui_resource_request_queue;
};

enum CommitEarlyOutReason {
  ABORTED_OUTPUT_SURFACE_LOST,
  ABORTED_NOT_VISIBLE,
  ABORTED_DEFERRED_COMMIT,
  FINISHED_NO_UPDATES,
};
